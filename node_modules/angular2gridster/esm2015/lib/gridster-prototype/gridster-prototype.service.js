import { __decorate, __metadata } from "tslib";
import { Injectable } from '@angular/core';
import { Subject, merge } from 'rxjs';
import { takeUntil, switchMap, map, scan, filter, share, tap } from 'rxjs/operators';
import { utils } from '../utils/utils';
let GridsterPrototypeService = class GridsterPrototypeService {
    constructor() {
        this.isDragging = false;
        this.dragSubject = new Subject();
        this.dragStartSubject = new Subject();
        this.dragStopSubject = new Subject();
    }
    observeDropOver(gridster) {
        return this.dragStopSubject.pipe(filter((data) => {
            const gridsterEl = gridster.gridsterComponent.$element;
            const isOverNestedGridster = [].slice.call(gridsterEl.querySelectorAll('gridster'))
                .reduce((isOverGridster, nestedGridsterEl) => {
                return isOverGridster ||
                    this.isOverGridster(data.item, nestedGridsterEl, data.event, gridster.options);
            }, false);
            if (isOverNestedGridster) {
                return false;
            }
            return this.isOverGridster(data.item, gridsterEl, data.event, gridster.options);
        }), tap((data) => {
            // TODO: what we should provide as a param?
            // prototype.drop.emit({item: prototype.item});
            data.item.onDrop(gridster);
        }));
    }
    observeDropOut(gridster) {
        return this.dragStopSubject.pipe(filter((data) => {
            const gridsterEl = gridster.gridsterComponent.$element;
            return !this.isOverGridster(data.item, gridsterEl, data.event, gridster.options);
        }), tap((data) => {
            // TODO: what we should provide as a param?
            data.item.onCancel();
        }));
    }
    observeDragOver(gridster) {
        const over = this.dragSubject.pipe(map((data) => {
            const gridsterEl = gridster.gridsterComponent.$element;
            return {
                item: data.item,
                event: data.event,
                isOver: this.isOverGridster(data.item, gridsterEl, data.event, gridster.options),
                isDrop: false
            };
        }));
        const drop = this.dragStopSubject.pipe(map((data) => {
            const gridsterEl = gridster.gridsterComponent.$element;
            return {
                item: data.item,
                event: data.event,
                isOver: this.isOverGridster(data.item, gridsterEl, data.event, gridster.options),
                isDrop: true
            };
        }));
        const dragExt = merge(
        // dragStartSubject is connected in case when item prototype is placed above gridster
        // and drag enter is not fired
        this.dragStartSubject.pipe(map(() => ({ item: null, isOver: false, isDrop: false }))), over, drop).pipe(scan((prev, next) => {
            return {
                item: next.item,
                event: next.event,
                isOver: next.isOver,
                isEnter: prev.isOver === false && next.isOver === true,
                isOut: prev.isOver === true && next.isOver === false && !prev.isDrop,
                isDrop: next.isDrop
            };
        }), filter((data) => {
            return !data.isDrop;
        }), share());
        const dragEnter = this.createDragEnterObservable(dragExt, gridster);
        const dragOut = this.createDragOutObservable(dragExt, gridster);
        const dragOver = dragEnter
            .pipe(switchMap(() => this.dragSubject.pipe(takeUntil(dragOut))), map((data) => data.item));
        return { dragEnter, dragOut, dragOver };
    }
    dragItemStart(item, event) {
        this.isDragging = true;
        this.dragStartSubject.next({ item, event });
    }
    dragItemStop(item, event) {
        this.isDragging = false;
        this.dragStopSubject.next({ item, event });
    }
    updatePrototypePosition(item, event) {
        this.dragSubject.next({ item, event });
    }
    /**
     * Creates observable that is fired on dragging over gridster container.
     */
    createDragOverObservable(dragIsOver, gridster) {
        return dragIsOver.pipe(filter((data) => data.isOver && !data.isEnter && !data.isOut), map((data) => data.item), tap((item) => item.onOver(gridster)));
    }
    /**
     * Creates observable that is fired on drag enter gridster container.
     */
    createDragEnterObservable(dragIsOver, gridster) {
        return dragIsOver.pipe(filter((data) => data.isEnter), map((data) => data.item), tap((item) => item.onEnter(gridster)));
    }
    /**
     * Creates observable that is fired on drag out gridster container.
     */
    createDragOutObservable(dragIsOver, gridster) {
        return dragIsOver.pipe(filter((data) => data.isOut), map((data) => data.item), tap((item) => item.onOut(gridster)));
    }
    /**
     * Checks whether "element" position fits inside "containerEl" position.
     * It checks if "element" is totally covered by "containerEl" area.
     */
    isOverGridster(item, gridsterEl, event, options) {
        const el = item.$element;
        const parentItem = gridsterEl.parentElement &&
            gridsterEl.parentElement.closest('gridster-item');
        if (parentItem) {
            return this.isOverGridster(item, parentItem, event, options);
        }
        switch (options.tolerance) {
            case 'fit':
                return utils.isElementFitContainer(el, gridsterEl);
            case 'intersect':
                return utils.isElementIntersectContainer(el, gridsterEl);
            case 'touch':
                return utils.isElementTouchContainer(el, gridsterEl);
            default:
                return utils.isCursorAboveElement(event, gridsterEl);
        }
    }
};
GridsterPrototypeService = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [])
], GridsterPrototypeService);
export { GridsterPrototypeService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZHN0ZXItcHJvdG90eXBlLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9hbmd1bGFyMmdyaWRzdGVyLyIsInNvdXJjZXMiOlsibGliL2dyaWRzdGVyLXByb3RvdHlwZS9ncmlkc3Rlci1wcm90b3R5cGUuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQWMsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNsRCxPQUFPLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFJckYsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBSXZDLElBQWEsd0JBQXdCLEdBQXJDLE1BQWEsd0JBQXdCO0lBVWpDO1FBUlEsZUFBVSxHQUFHLEtBQUssQ0FBQztRQUVuQixnQkFBVyxHQUFHLElBQUksT0FBTyxFQUFPLENBQUM7UUFFakMscUJBQWdCLEdBQUcsSUFBSSxPQUFPLEVBQU8sQ0FBQztRQUV0QyxvQkFBZSxHQUFHLElBQUksT0FBTyxFQUFPLENBQUM7SUFFOUIsQ0FBQztJQUVoQixlQUFlLENBQUUsUUFBeUI7UUFDdEMsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FDNUIsTUFBTSxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUU7WUFDWixNQUFNLFVBQVUsR0FBRyxRQUFRLENBQUMsaUJBQWlCLENBQUMsUUFBUSxDQUFDO1lBQ3ZELE1BQU0sb0JBQW9CLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxDQUFDO2lCQUM5RSxNQUFNLENBQUMsQ0FBQyxjQUFjLEVBQUUsZ0JBQWdCLEVBQUUsRUFBRTtnQkFDekMsT0FBTyxjQUFjO29CQUNqQixJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsZ0JBQWdCLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDdkYsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBRWQsSUFBSSxvQkFBb0IsRUFBRTtnQkFDdEIsT0FBTyxLQUFLLENBQUM7YUFDaEI7WUFFRCxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxVQUFVLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDcEYsQ0FBQyxDQUFDLEVBQ0YsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUU7WUFDVCwyQ0FBMkM7WUFDM0MsK0NBQStDO1lBQy9DLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQy9CLENBQUMsQ0FBQyxDQUNMLENBQUM7SUFDTixDQUFDO0lBRUQsY0FBYyxDQUFFLFFBQXlCO1FBQ3JDLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQzVCLE1BQU0sQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFO1lBQ1osTUFBTSxVQUFVLEdBQUcsUUFBUSxDQUFDLGlCQUFpQixDQUFDLFFBQVEsQ0FBQztZQUV2RCxPQUFPLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFVBQVUsRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNyRixDQUFDLENBQUMsRUFDRixHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRTtZQUNULDJDQUEyQztZQUMzQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ3pCLENBQUMsQ0FBQyxDQUNMLENBQUM7SUFDTixDQUFDO0lBRUQsZUFBZSxDQUFDLFFBQXlCO1FBS3JDLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUM5QixHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRTtZQUNULE1BQU0sVUFBVSxHQUFHLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLENBQUM7WUFFdkQsT0FBTztnQkFDTCxJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUk7Z0JBQ2YsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLO2dCQUNqQixNQUFNLEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFVBQVUsRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxPQUFPLENBQUM7Z0JBQ2hGLE1BQU0sRUFBRSxLQUFLO2FBQ2QsQ0FBQztRQUNOLENBQUMsQ0FBQyxDQUNMLENBQUM7UUFFRixNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FDbEMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUU7WUFDVCxNQUFNLFVBQVUsR0FBRyxRQUFRLENBQUMsaUJBQWlCLENBQUMsUUFBUSxDQUFDO1lBRXZELE9BQU87Z0JBQ0gsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO2dCQUNmLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSztnQkFDakIsTUFBTSxFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxVQUFVLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsT0FBTyxDQUFDO2dCQUNoRixNQUFNLEVBQUUsSUFBSTthQUNmLENBQUM7UUFDTixDQUFDLENBQUMsQ0FDTCxDQUFDO1FBRUYsTUFBTSxPQUFPLEdBQUcsS0FBSztRQUNiLHFGQUFxRjtRQUNyRiw4QkFBOEI7UUFDOUIsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQ3JGLElBQUksRUFDSixJQUFJLENBQ1AsQ0FBQyxJQUFJLENBQ0YsSUFBSSxDQUFDLENBQUMsSUFBUyxFQUFFLElBQVMsRUFBRSxFQUFFO1lBQzFCLE9BQU87Z0JBQ0gsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO2dCQUNmLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSztnQkFDakIsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNO2dCQUNuQixPQUFPLEVBQUUsSUFBSSxDQUFDLE1BQU0sS0FBSyxLQUFLLElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxJQUFJO2dCQUN0RCxLQUFLLEVBQUUsSUFBSSxDQUFDLE1BQU0sS0FBSyxJQUFJLElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxLQUFLLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTTtnQkFDcEUsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNO2FBQ3RCLENBQUM7UUFDTixDQUFDLENBQUMsRUFDRixNQUFNLENBQUMsQ0FBQyxJQUFTLEVBQUUsRUFBRTtZQUNqQixPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUN4QixDQUFDLENBQUMsRUFDRixLQUFLLEVBQUUsQ0FDVixDQUFDO1FBRU4sTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLHlCQUF5QixDQUFDLE9BQU8sRUFBRSxRQUFRLENBQUMsQ0FBQztRQUNwRSxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsdUJBQXVCLENBQUMsT0FBTyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBQ2hFLE1BQU0sUUFBUSxHQUFHLFNBQVM7YUFDckIsSUFBSSxDQUNELFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUMxRCxHQUFHLENBQUMsQ0FBQyxJQUFTLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FDaEMsQ0FBQztRQUVOLE9BQU8sRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxDQUFDO0lBQzVDLENBQUM7SUFFRCxhQUFhLENBQUMsSUFBb0MsRUFBRSxLQUFxQjtRQUNyRSxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQztRQUN2QixJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7SUFDaEQsQ0FBQztJQUVELFlBQVksQ0FBQyxJQUFvQyxFQUFFLEtBQXFCO1FBQ3BFLElBQUksQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDO1FBQ3hCLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUVELHVCQUF1QixDQUFDLElBQW9DLEVBQUUsS0FBcUI7UUFDL0UsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztJQUMzQyxDQUFDO0lBRUQ7O09BRUc7SUFDSyx3QkFBd0IsQ0FDNUIsVUFBK0UsRUFDL0UsUUFBeUI7UUFFekIsT0FBTyxVQUFVLENBQUMsSUFBSSxDQUNsQixNQUFNLENBQUMsQ0FBQyxJQUFTLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxNQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUNsRSxHQUFHLENBQUMsQ0FBQyxJQUFTLEVBQWtDLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQzdELEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUN2QyxDQUFDO0lBQ04sQ0FBQztJQUNEOztPQUVHO0lBQ0sseUJBQXlCLENBQzdCLFVBQStFLEVBQy9FLFFBQXlCO1FBRXpCLE9BQU8sVUFBVSxDQUFDLElBQUksQ0FDbEIsTUFBTSxDQUFDLENBQUMsSUFBUyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQ25DLEdBQUcsQ0FBQyxDQUFDLElBQVMsRUFBa0MsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFDN0QsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQ3hDLENBQUM7SUFDTixDQUFDO0lBQ0Q7O09BRUc7SUFDSyx1QkFBdUIsQ0FDM0IsVUFDaUIsRUFDakIsUUFBeUI7UUFFekIsT0FBTyxVQUFVLENBQUMsSUFBSSxDQUNsQixNQUFNLENBQUMsQ0FBQyxJQUFTLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFDakMsR0FBRyxDQUFDLENBQUMsSUFBUyxFQUFrQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUM3RCxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FDdEMsQ0FBQztJQUNOLENBQUM7SUFFRDs7O09BR0c7SUFDSyxjQUFjLENBQUMsSUFBb0MsRUFBRSxVQUF1QixFQUFFLEtBQUssRUFBRSxPQUFPO1FBQ2hHLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDekIsTUFBTSxVQUFVLEdBQWdCLFVBQVUsQ0FBQyxhQUFhO1lBQ3ZDLFVBQVUsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBRW5FLElBQUksVUFBVSxFQUFFO1lBQ1osT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1NBQ2hFO1FBRUQsUUFBUSxPQUFPLENBQUMsU0FBUyxFQUFFO1lBQ3ZCLEtBQUssS0FBSztnQkFDTixPQUFPLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxFQUFFLEVBQUUsVUFBVSxDQUFDLENBQUM7WUFDdkQsS0FBSyxXQUFXO2dCQUNaLE9BQU8sS0FBSyxDQUFDLDJCQUEyQixDQUFDLEVBQUUsRUFBRSxVQUFVLENBQUMsQ0FBQztZQUM3RCxLQUFLLE9BQU87Z0JBQ1IsT0FBTyxLQUFLLENBQUMsdUJBQXVCLENBQUMsRUFBRSxFQUFFLFVBQVUsQ0FBQyxDQUFDO1lBQ3pEO2dCQUNJLE9BQU8sS0FBSyxDQUFDLG9CQUFvQixDQUFDLEtBQUssRUFBRSxVQUFVLENBQUMsQ0FBQztTQUM1RDtJQUNMLENBQUM7Q0FDSixDQUFBO0FBbE1ZLHdCQUF3QjtJQURwQyxVQUFVLEVBQUU7O0dBQ0Esd0JBQXdCLENBa01wQztTQWxNWSx3QkFBd0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0LCBtZXJnZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdGFrZVVudGlsLCBzd2l0Y2hNYXAsIG1hcCwgc2NhbiwgZmlsdGVyLCBzaGFyZSwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBHcmlkc3RlclNlcnZpY2UgfSBmcm9tICcuLi9ncmlkc3Rlci5zZXJ2aWNlJztcbmltcG9ydCB7IEdyaWRzdGVySXRlbVByb3RvdHlwZURpcmVjdGl2ZSB9IGZyb20gJy4vZ3JpZHN0ZXItaXRlbS1wcm90b3R5cGUuZGlyZWN0aXZlJztcbmltcG9ydCB7IHV0aWxzIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IHsgRHJhZ2dhYmxlRXZlbnQgfSBmcm9tICcuLi91dGlscy9EcmFnZ2FibGVFdmVudCc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBHcmlkc3RlclByb3RvdHlwZVNlcnZpY2Uge1xuXG4gICAgcHJpdmF0ZSBpc0RyYWdnaW5nID0gZmFsc2U7XG5cbiAgICBwcml2YXRlIGRyYWdTdWJqZWN0ID0gbmV3IFN1YmplY3Q8YW55PigpO1xuXG4gICAgcHJpdmF0ZSBkcmFnU3RhcnRTdWJqZWN0ID0gbmV3IFN1YmplY3Q8YW55PigpO1xuXG4gICAgcHJpdmF0ZSBkcmFnU3RvcFN1YmplY3QgPSBuZXcgU3ViamVjdDxhbnk+KCk7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgICBvYnNlcnZlRHJvcE92ZXIgKGdyaWRzdGVyOiBHcmlkc3RlclNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ1N0b3BTdWJqZWN0LnBpcGUoXG4gICAgICAgICAgICBmaWx0ZXIoKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBncmlkc3RlckVsID0gZ3JpZHN0ZXIuZ3JpZHN0ZXJDb21wb25lbnQuJGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNPdmVyTmVzdGVkR3JpZHN0ZXIgPSBbXS5zbGljZS5jYWxsKGdyaWRzdGVyRWwucXVlcnlTZWxlY3RvckFsbCgnZ3JpZHN0ZXInKSlcbiAgICAgICAgICAgICAgICAgICAgLnJlZHVjZSgoaXNPdmVyR3JpZHN0ZXIsIG5lc3RlZEdyaWRzdGVyRWwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc092ZXJHcmlkc3RlciB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNPdmVyR3JpZHN0ZXIoZGF0YS5pdGVtLCBuZXN0ZWRHcmlkc3RlckVsLCBkYXRhLmV2ZW50LCBncmlkc3Rlci5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzT3Zlck5lc3RlZEdyaWRzdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc092ZXJHcmlkc3RlcihkYXRhLml0ZW0sIGdyaWRzdGVyRWwsIGRhdGEuZXZlbnQsIGdyaWRzdGVyLm9wdGlvbnMpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0YXAoKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB3aGF0IHdlIHNob3VsZCBwcm92aWRlIGFzIGEgcGFyYW0/XG4gICAgICAgICAgICAgICAgLy8gcHJvdG90eXBlLmRyb3AuZW1pdCh7aXRlbTogcHJvdG90eXBlLml0ZW19KTtcbiAgICAgICAgICAgICAgICBkYXRhLml0ZW0ub25Ecm9wKGdyaWRzdGVyKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgb2JzZXJ2ZURyb3BPdXQgKGdyaWRzdGVyOiBHcmlkc3RlclNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ1N0b3BTdWJqZWN0LnBpcGUoXG4gICAgICAgICAgICBmaWx0ZXIoKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBncmlkc3RlckVsID0gZ3JpZHN0ZXIuZ3JpZHN0ZXJDb21wb25lbnQuJGVsZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gIXRoaXMuaXNPdmVyR3JpZHN0ZXIoZGF0YS5pdGVtLCBncmlkc3RlckVsLCBkYXRhLmV2ZW50LCBncmlkc3Rlci5vcHRpb25zKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdGFwKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogd2hhdCB3ZSBzaG91bGQgcHJvdmlkZSBhcyBhIHBhcmFtP1xuICAgICAgICAgICAgICAgIGRhdGEuaXRlbS5vbkNhbmNlbCgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBvYnNlcnZlRHJhZ092ZXIoZ3JpZHN0ZXI6IEdyaWRzdGVyU2VydmljZSk6IHtcbiAgICAgICAgZHJhZ092ZXI6IE9ic2VydmFibGU8R3JpZHN0ZXJJdGVtUHJvdG90eXBlRGlyZWN0aXZlPixcbiAgICAgICAgZHJhZ0VudGVyOiBPYnNlcnZhYmxlPEdyaWRzdGVySXRlbVByb3RvdHlwZURpcmVjdGl2ZT4sXG4gICAgICAgIGRyYWdPdXQ6IE9ic2VydmFibGU8R3JpZHN0ZXJJdGVtUHJvdG90eXBlRGlyZWN0aXZlPlxuICAgIH0ge1xuICAgICAgICBjb25zdCBvdmVyID0gdGhpcy5kcmFnU3ViamVjdC5waXBlKFxuICAgICAgICAgICAgbWFwKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ3JpZHN0ZXJFbCA9IGdyaWRzdGVyLmdyaWRzdGVyQ29tcG9uZW50LiRlbGVtZW50O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIGl0ZW06IGRhdGEuaXRlbSxcbiAgICAgICAgICAgICAgICAgIGV2ZW50OiBkYXRhLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgaXNPdmVyOiB0aGlzLmlzT3ZlckdyaWRzdGVyKGRhdGEuaXRlbSwgZ3JpZHN0ZXJFbCwgZGF0YS5ldmVudCwgZ3JpZHN0ZXIub3B0aW9ucyksXG4gICAgICAgICAgICAgICAgICBpc0Ryb3A6IGZhbHNlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgZHJvcCA9IHRoaXMuZHJhZ1N0b3BTdWJqZWN0LnBpcGUoXG4gICAgICAgICAgICBtYXAoKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBncmlkc3RlckVsID0gZ3JpZHN0ZXIuZ3JpZHN0ZXJDb21wb25lbnQuJGVsZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpdGVtOiBkYXRhLml0ZW0sXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBkYXRhLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBpc092ZXI6IHRoaXMuaXNPdmVyR3JpZHN0ZXIoZGF0YS5pdGVtLCBncmlkc3RlckVsLCBkYXRhLmV2ZW50LCBncmlkc3Rlci5vcHRpb25zKSxcbiAgICAgICAgICAgICAgICAgICAgaXNEcm9wOiB0cnVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgZHJhZ0V4dCA9IG1lcmdlKFxuICAgICAgICAgICAgICAgIC8vIGRyYWdTdGFydFN1YmplY3QgaXMgY29ubmVjdGVkIGluIGNhc2Ugd2hlbiBpdGVtIHByb3RvdHlwZSBpcyBwbGFjZWQgYWJvdmUgZ3JpZHN0ZXJcbiAgICAgICAgICAgICAgICAvLyBhbmQgZHJhZyBlbnRlciBpcyBub3QgZmlyZWRcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdTdGFydFN1YmplY3QucGlwZShtYXAoKCkgPT4gKHsgaXRlbTogbnVsbCwgaXNPdmVyOiBmYWxzZSwgaXNEcm9wOiBmYWxzZSB9KSkpLFxuICAgICAgICAgICAgICAgIG92ZXIsXG4gICAgICAgICAgICAgICAgZHJvcFxuICAgICAgICAgICAgKS5waXBlKFxuICAgICAgICAgICAgICAgIHNjYW4oKHByZXY6IGFueSwgbmV4dDogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtOiBuZXh0Lml0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogbmV4dC5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzT3ZlcjogbmV4dC5pc092ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0VudGVyOiBwcmV2LmlzT3ZlciA9PT0gZmFsc2UgJiYgbmV4dC5pc092ZXIgPT09IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc091dDogcHJldi5pc092ZXIgPT09IHRydWUgJiYgbmV4dC5pc092ZXIgPT09IGZhbHNlICYmICFwcmV2LmlzRHJvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRHJvcDogbmV4dC5pc0Ryb3BcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBmaWx0ZXIoKGRhdGE6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWRhdGEuaXNEcm9wO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHNoYXJlKClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgZHJhZ0VudGVyID0gdGhpcy5jcmVhdGVEcmFnRW50ZXJPYnNlcnZhYmxlKGRyYWdFeHQsIGdyaWRzdGVyKTtcbiAgICAgICAgY29uc3QgZHJhZ091dCA9IHRoaXMuY3JlYXRlRHJhZ091dE9ic2VydmFibGUoZHJhZ0V4dCwgZ3JpZHN0ZXIpO1xuICAgICAgICBjb25zdCBkcmFnT3ZlciA9IGRyYWdFbnRlclxuICAgICAgICAgICAgLnBpcGUoXG4gICAgICAgICAgICAgICAgc3dpdGNoTWFwKCgpID0+IHRoaXMuZHJhZ1N1YmplY3QucGlwZSh0YWtlVW50aWwoZHJhZ091dCkpKSxcbiAgICAgICAgICAgICAgICBtYXAoKGRhdGE6IGFueSkgPT4gZGF0YS5pdGVtKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4geyBkcmFnRW50ZXIsIGRyYWdPdXQsIGRyYWdPdmVyIH07XG4gICAgfVxuXG4gICAgZHJhZ0l0ZW1TdGFydChpdGVtOiBHcmlkc3Rlckl0ZW1Qcm90b3R5cGVEaXJlY3RpdmUsIGV2ZW50OiBEcmFnZ2FibGVFdmVudCkge1xuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmRyYWdTdGFydFN1YmplY3QubmV4dCh7IGl0ZW0sIGV2ZW50IH0pO1xuICAgIH1cblxuICAgIGRyYWdJdGVtU3RvcChpdGVtOiBHcmlkc3Rlckl0ZW1Qcm90b3R5cGVEaXJlY3RpdmUsIGV2ZW50OiBEcmFnZ2FibGVFdmVudCkge1xuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kcmFnU3RvcFN1YmplY3QubmV4dCh7IGl0ZW0sIGV2ZW50IH0pO1xuICAgIH1cblxuICAgIHVwZGF0ZVByb3RvdHlwZVBvc2l0aW9uKGl0ZW06IEdyaWRzdGVySXRlbVByb3RvdHlwZURpcmVjdGl2ZSwgZXZlbnQ6IERyYWdnYWJsZUV2ZW50KSB7XG4gICAgICAgIHRoaXMuZHJhZ1N1YmplY3QubmV4dCh7IGl0ZW0sIGV2ZW50IH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgb2JzZXJ2YWJsZSB0aGF0IGlzIGZpcmVkIG9uIGRyYWdnaW5nIG92ZXIgZ3JpZHN0ZXIgY29udGFpbmVyLlxuICAgICAqL1xuICAgIHByaXZhdGUgY3JlYXRlRHJhZ092ZXJPYnNlcnZhYmxlIChcbiAgICAgICAgZHJhZ0lzT3ZlcjogT2JzZXJ2YWJsZTx7aXRlbTogR3JpZHN0ZXJJdGVtUHJvdG90eXBlRGlyZWN0aXZlLCBpc092ZXI6IGJvb2xlYW59PixcbiAgICAgICAgZ3JpZHN0ZXI6IEdyaWRzdGVyU2VydmljZVxuICAgICkge1xuICAgICAgICByZXR1cm4gZHJhZ0lzT3Zlci5waXBlKFxuICAgICAgICAgICAgZmlsdGVyKChkYXRhOiBhbnkpID0+IGRhdGEuaXNPdmVyICYmICFkYXRhLmlzRW50ZXIgJiYgIWRhdGEuaXNPdXQpLFxuICAgICAgICAgICAgbWFwKChkYXRhOiBhbnkpOiBHcmlkc3Rlckl0ZW1Qcm90b3R5cGVEaXJlY3RpdmUgPT4gZGF0YS5pdGVtKSxcbiAgICAgICAgICAgIHRhcCgoaXRlbSkgPT4gaXRlbS5vbk92ZXIoZ3JpZHN0ZXIpKVxuICAgICAgICApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG9ic2VydmFibGUgdGhhdCBpcyBmaXJlZCBvbiBkcmFnIGVudGVyIGdyaWRzdGVyIGNvbnRhaW5lci5cbiAgICAgKi9cbiAgICBwcml2YXRlIGNyZWF0ZURyYWdFbnRlck9ic2VydmFibGUgKFxuICAgICAgICBkcmFnSXNPdmVyOiBPYnNlcnZhYmxlPHtpdGVtOiBHcmlkc3Rlckl0ZW1Qcm90b3R5cGVEaXJlY3RpdmUsIGlzT3ZlcjogYm9vbGVhbn0+LFxuICAgICAgICBncmlkc3RlcjogR3JpZHN0ZXJTZXJ2aWNlXG4gICAgKSB7XG4gICAgICAgIHJldHVybiBkcmFnSXNPdmVyLnBpcGUoXG4gICAgICAgICAgICBmaWx0ZXIoKGRhdGE6IGFueSkgPT4gZGF0YS5pc0VudGVyKSxcbiAgICAgICAgICAgIG1hcCgoZGF0YTogYW55KTogR3JpZHN0ZXJJdGVtUHJvdG90eXBlRGlyZWN0aXZlID0+IGRhdGEuaXRlbSksXG4gICAgICAgICAgICB0YXAoKGl0ZW0pID0+IGl0ZW0ub25FbnRlcihncmlkc3RlcikpXG4gICAgICAgICk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgb2JzZXJ2YWJsZSB0aGF0IGlzIGZpcmVkIG9uIGRyYWcgb3V0IGdyaWRzdGVyIGNvbnRhaW5lci5cbiAgICAgKi9cbiAgICBwcml2YXRlIGNyZWF0ZURyYWdPdXRPYnNlcnZhYmxlIChcbiAgICAgICAgZHJhZ0lzT3ZlcjogT2JzZXJ2YWJsZTx7aXRlbTogR3JpZHN0ZXJJdGVtUHJvdG90eXBlRGlyZWN0aXZlLFxuICAgICAgICBpc092ZXI6IGJvb2xlYW59PixcbiAgICAgICAgZ3JpZHN0ZXI6IEdyaWRzdGVyU2VydmljZVxuICAgICkge1xuICAgICAgICByZXR1cm4gZHJhZ0lzT3Zlci5waXBlKFxuICAgICAgICAgICAgZmlsdGVyKChkYXRhOiBhbnkpID0+IGRhdGEuaXNPdXQpLFxuICAgICAgICAgICAgbWFwKChkYXRhOiBhbnkpOiBHcmlkc3Rlckl0ZW1Qcm90b3R5cGVEaXJlY3RpdmUgPT4gZGF0YS5pdGVtKSxcbiAgICAgICAgICAgIHRhcCgoaXRlbSkgPT4gaXRlbS5vbk91dChncmlkc3RlcikpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgXCJlbGVtZW50XCIgcG9zaXRpb24gZml0cyBpbnNpZGUgXCJjb250YWluZXJFbFwiIHBvc2l0aW9uLlxuICAgICAqIEl0IGNoZWNrcyBpZiBcImVsZW1lbnRcIiBpcyB0b3RhbGx5IGNvdmVyZWQgYnkgXCJjb250YWluZXJFbFwiIGFyZWEuXG4gICAgICovXG4gICAgcHJpdmF0ZSBpc092ZXJHcmlkc3RlcihpdGVtOiBHcmlkc3Rlckl0ZW1Qcm90b3R5cGVEaXJlY3RpdmUsIGdyaWRzdGVyRWw6IEhUTUxFbGVtZW50LCBldmVudCwgb3B0aW9ucyk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBlbCA9IGl0ZW0uJGVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHBhcmVudEl0ZW0gPSA8SFRNTEVsZW1lbnQ+Z3JpZHN0ZXJFbC5wYXJlbnRFbGVtZW50ICYmXG4gICAgICAgICAgICA8SFRNTEVsZW1lbnQ+Z3JpZHN0ZXJFbC5wYXJlbnRFbGVtZW50LmNsb3Nlc3QoJ2dyaWRzdGVyLWl0ZW0nKTtcblxuICAgICAgICBpZiAocGFyZW50SXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNPdmVyR3JpZHN0ZXIoaXRlbSwgcGFyZW50SXRlbSwgZXZlbnQsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChvcHRpb25zLnRvbGVyYW5jZSkge1xuICAgICAgICAgICAgY2FzZSAnZml0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbHMuaXNFbGVtZW50Rml0Q29udGFpbmVyKGVsLCBncmlkc3RlckVsKTtcbiAgICAgICAgICAgIGNhc2UgJ2ludGVyc2VjdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmlzRWxlbWVudEludGVyc2VjdENvbnRhaW5lcihlbCwgZ3JpZHN0ZXJFbCk7XG4gICAgICAgICAgICBjYXNlICd0b3VjaCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmlzRWxlbWVudFRvdWNoQ29udGFpbmVyKGVsLCBncmlkc3RlckVsKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmlzQ3Vyc29yQWJvdmVFbGVtZW50KGV2ZW50LCBncmlkc3RlckVsKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdfQ==