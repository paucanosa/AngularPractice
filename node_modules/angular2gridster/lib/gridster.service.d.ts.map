{"version":3,"file":"gridster.service.d.ts","sources":["gridster.service.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { Subject } from 'rxjs';\nimport { GridList } from './gridList/gridList';\nimport { IGridsterOptions } from './IGridsterOptions';\nimport { IGridsterDraggableOptions } from './IGridsterDraggableOptions';\nimport { GridListItem } from './gridList/GridListItem';\nimport { GridsterComponent } from './gridster.component';\nimport { GridsterOptions } from './GridsterOptions';\nexport declare class GridsterService {\n    $element: HTMLElement;\n    gridList: GridList;\n    items: Array<GridListItem>;\n    _items: Array<GridListItem>;\n    _itemsMap: {\n        [breakpoint: string]: Array<GridListItem>;\n    };\n    disabledItems: Array<GridListItem>;\n    options: IGridsterOptions;\n    draggableOptions: IGridsterDraggableOptions;\n    gridsterRect: ClientRect;\n    gridsterScrollData: {\n        scrollTop: number;\n        scrollLeft: number;\n    };\n    gridsterOptions: GridsterOptions;\n    gridsterComponent: GridsterComponent;\n    debounceRenderSubject: Subject<unknown>;\n    $positionHighlight: HTMLElement;\n    maxItemWidth: number;\n    maxItemHeight: number;\n    cellWidth: number;\n    cellHeight: number;\n    itemRemoveSubject: Subject<GridListItem>;\n    private _fontSize;\n    private previousDragPosition;\n    private previousDragSize;\n    private currentElement;\n    private _maxGridCols;\n    private isInit;\n    constructor();\n    isInitialized(): boolean;\n    /**\n     * Must be called before init\n     * @param item\n     */\n    registerItem(item: GridListItem): GridListItem;\n    init(gridsterComponent: GridsterComponent): void;\n    start(): void;\n    initGridList(): void;\n    render(): void;\n    reflow(): void;\n    fixItemsPositions(): void;\n    removeItem(item: GridListItem): void;\n    onResizeStart(item: GridListItem): void;\n    onResizeDrag(item: GridListItem): void;\n    onResizeStop(item: GridListItem): void;\n    onStart(item: GridListItem): void;\n    onDrag(item: GridListItem): void;\n    cancel(): void;\n    onDragOut(item: GridListItem): void;\n    onStop(item: GridListItem): void;\n    calculateCellSize(): void;\n    applyPositionToItems(increaseGridsterSize?: any): void;\n    refreshLines(): void;\n    private removeItemFromCache;\n    private copyItems;\n    /**\n     * Update maxItemWidth and maxItemHeight vales according to current state of items\n     */\n    private updateMaxItemSize;\n    /**\n     * Update items properties of previously cached items\n     */\n    private restoreCachedItems;\n    /**\n     * If item should react on grid\n     * @param GridListItem item\n     * @returns boolean\n     */\n    private isValidGridItem;\n    private calculateCellWidth;\n    private calculateCellHeight;\n    private applySizeToItems;\n    private isCurrentElement;\n    private snapItemSizeToGrid;\n    private generateItemPosition;\n    private snapItemPositionToGrid;\n    private dragSizeChanged;\n    private dragPositionChanged;\n    private highlightPositionForItem;\n    updateCachedItems(): void;\n    private triggerOnChange;\n    private removePositionHighlight;\n}\n"]}